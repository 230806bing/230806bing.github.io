<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>安卓学习路线</title>
    <link href="/2021/07/12/%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <url>/2021/07/12/%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓学习路线"><a href="#安卓学习路线" class="headerlink" title="安卓学习路线"></a>安卓学习路线</h1><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="1-四大组件"><a href="#1-四大组件" class="headerlink" title="1. 四大组件"></a>1. 四大组件</h3><p><strong>Activity、Service、BroadcastReceiver、Content Provider</strong></p><p>Activity就不用多介绍啦，相信大家跟它都是老朋友啦，Activity是我们肯定要掌握掌握掌握的，大家要掌握好Activity的生命周期、启动模式以及数据传递等。</p><p>Service主要提供需在后台长期运行的服务，如：音乐播放、后台下载等。它是Android中实现程序后台运行的解决方案，非常适合去执行那些不需要和用户交互而且还要求长期运行的任务。这里大家要掌握好service的生命周期以及基本用法。</p><p>BroadcastReceiver是广播，广播机制是Android系统中用于发送和接收广播消息的一种手段。例如手机快没电的提示信息、没信号时的提示信息都属于广播的一种。它可以监听/接收App 发出的广播消息，并做出响应。学会实现接收广播和发送广播。</p><p>Content Provider主要用于在不同应用程序之间进行数据交互&amp;共享，允许访问其他程序中的数据的同时还保证了数据的安全性。首先学习安卓相关的权限机制并尝试实现访问其他应用程序的数据。</p><p>学习资源：</p><ul><li><p>《第一行代码》</p></li><li><p><a href="https://blog.csdn.net/qq_29966203/article/details/90346296">https://blog.csdn.net/qq_29966203/article/details/90346296</a></p></li><li><p><a href="https://blog.csdn.net/qq_29966203/article/details/90381812">https://blog.csdn.net/qq_29966203/article/details/90381812</a></p></li><li><p><a href="https://blog.csdn.net/qq_29966203/article/details/90383221">https://blog.csdn.net/qq_29966203/article/details/90383221</a></p></li><li><p><a href="https://blog.csdn.net/qq_29966203/article/details/90382633">https://blog.csdn.net/qq_29966203/article/details/90382633</a></p></li></ul><h3 id="2-Fragment"><a href="#2-Fragment" class="headerlink" title="2. Fragment"></a>2. Fragment</h3><p>碎片是之前上过课的内容，大家可以接着巩固一下，然后学习新的碎片相关的知识，特别要掌握好碎片和活动、碎片和碎片之间的通信。关于fragment到时候每个人做出一个小demo，大家可以以《第一行代码》中的实践作为demo练手，或者自己从网上找到相关的demo也可以。</p><p>学习资源：</p><ul><li>《第一行代码》</li><li><a href="https://blog.csdn.net/wasabidragon/article/details/108914570">https://blog.csdn.net/wasabidragon/article/details/108914570</a></li><li><a href="https://blackdn.github.io/2019/10/25/Greet-Fragment-2019/">https://blackdn.github.io/2019/10/25/Greet-Fragment-2019/</a></li><li><a href="https://blog.csdn.net/qq_29966203/article/details/90414221">https://blog.csdn.net/qq_29966203/article/details/90414221</a></li></ul><h3 id="3-UI和布局"><a href="#3-UI和布局" class="headerlink" title="3. UI和布局"></a>3. UI和布局</h3><p>UI（用户界面）：应用的用户界面是我们在 Android 设备屏幕上所看到的内容。用户界面包括一个或多个用于显示信息的矩形区域，称为视图。部分视图（如按钮）还可以对触摸做出响应。<br>布局：应用的布局指屏幕上显示的设计或布置。该用户界面由视图矩形区域构成。大视图可以包含小视图，并且始终有一个包含所有其他视图的最大视图。</p><p>Android提供了大量预定义的UI组件，比如Layout资源，除此之外，Android还提供了特殊的UI模型，如dialogs、notifications、menus 等。<br>对于最基础的UI控件和布局（第一行代码中罗列的几个）之外，如果有余力的同学也可以去多了解几个其他的控件，有助于对未来需求的判断，另外拓展篇的自定义控件也是很重要的。</p><p>学习资源：<br><a href="https://blog.csdn.net/vanpersie_9987/article/details/51837594">https://blog.csdn.net/vanpersie_9987/article/details/51837594</a><br><a href="https://blog.csdn.net/vanpersie_9987/article/details/51921161">https://blog.csdn.net/vanpersie_9987/article/details/51921161</a><br>见最低的##学习资源</p><h3 id="4-数据存储"><a href="#4-数据存储" class="headerlink" title="4. 数据存储"></a>4. 数据存储</h3><p>android 五种数据存储 ：<br>File、SharePreferences、SQLite、Contert Provider、网络存储<br>Android系统提供了四种存储数据方式。分别为：File、SharePreference、SQLite和Content Provider。但由于Android系统中，数据基本是私有的，都是存放于”data/data”程序包名目录下，所以要实现数据共享，正确方式是使用Content Provider。<br>网络存储则涉及到网络通信方面的问题，我们可以调用WebService返回的数据或是解析HTTP协议实现网络数据交互。</p><h3 id="5-进程与线程"><a href="#5-进程与线程" class="headerlink" title="5. 进程与线程"></a>5. 进程与线程</h3><p>这部分内容之前上课也讲到过，他们会经常跟服务一起出现。</p><p>内容包括线程的基本用法，异步消息处理机制以及一些工具（抽象类）如AsyncTask等。这些都是为四大组件之一——服务做基础的。</p><p>进程的优先级，线程的切换等等的知识也是需要去了解的。</p><h3 id="6-网络通信"><a href="#6-网络通信" class="headerlink" title="6. 网络通信"></a>6. 网络通信</h3><p>这部分在讲对接的时候也讲过一点，使用OkHttp进行网络通信。</p><p>安卓开发常用的一些网络通信技术，主要包括如何使用多线程完成异步操作、如何进行HTTP接口调用与图片获取、如何实现文件上传和下载操作、如何运用Socket通信技术。学习了网络通信后，我们还要学习数据解析，常见的如XML格式数据的解析，JSON格式数据的解析等。</p><p>学习资源：</p><ul><li>《第一行代码》第九章</li></ul><h3 id="7-安卓开发框架"><a href="#7-安卓开发框架" class="headerlink" title="7. 安卓开发框架"></a>7. 安卓开发框架</h3><p>通俗的说，框架是实现某种功能的半成品，提供了一些常用的工具类和一些基础通用化的组件，可以供开发人员在此基础上，更高效的满足各自的业务需求。一个优秀的的框架，它相当于是一个模板代码库，很多基础性的功能,底层功能操作都已经帮我们实现了，我们只需要专心的实现所需要的业务逻辑就可以了。</p><p>框架特点：</p><p>1.代码模板化：每个框架都有自己的使用规范，如：创建类、接口等的规范<br>2.重用性、通用性：不分行业、不分业务，只要功能相似就可以稍加修改即可使用<br>3.高内聚（封装）：各种基础的功能都封装好了，只需要在使用的时候调用就可以。无需关注底层实现原理。<br>4.可扩展、可维护：框架的使用都有约定俗称的操作规范，无论任何人使用，只要按照规范操作，就可以轻松使用。</p><p>学习资源：</p><ul><li>MVC、MVP、MVVM的理解：<a href="https://mp.weixin.qq.com/s/aRon6QtRuQwlqIZmhZIsOQ">https://mp.weixin.qq.com/s/aRon6QtRuQwlqIZmhZIsOQ</a></li><li><a href="https://blog.csdn.net/u012440207/article/details/82493518">https://blog.csdn.net/u012440207/article/details/82493518</a></li><li>这个列了很多很多框架，可以选择性去学习一下：<a href="https://blog.csdn.net/qq_42618969/article/details/81941242">https://blog.csdn.net/qq_42618969/article/details/81941242</a></li><li>一个MVVM架构的开源小项目： <a href="https://mp.weixin.qq.com/s/PCkVsD8nPJV3wXkPg_6yDw">https://mp.weixin.qq.com/s/PCkVsD8nPJV3wXkPg_6yDw</a></li><li><a href="https://github.com/SenhLinsh/Android-Hot-Libraries">https://github.com/SenhLinsh/Android-Hot-Libraries</a></li></ul><h2 id="扩展篇"><a href="#扩展篇" class="headerlink" title="扩展篇"></a>扩展篇</h2><h3 id="1-kotlin语法"><a href="#1-kotlin语法" class="headerlink" title="1. kotlin语法"></a>1. kotlin语法</h3><p>在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。未来kotlin一定是安卓开发的大方向，所以学好kotlin也是非常重要的。这方面由于Quanta也是在起步阶段，所以还需要大家自己多去学习一下。不过还是建议大家先入门了Java之后再转向kotlin，成本不会很高，网络上的教程也是Java比较多一些。</p><p>Kotlin也是基于JVM设计的编程语言，算是对Java的温和改良，相对Java来说，Kotlin在编写代码时有如下优势：代码简洁高效、函数式编程、空指针安全、支持lambda表达式、流式API等。</p><p>如果可以的话尽量多用demo来练习，熟能生巧。</p><p>学习资源：</p><p>kotlin官方网址：</p><p><a href="https://kotlinlang.org/docs/home.html">https://kotlinlang.org/docs/home.html</a></p><p>kotlin菜鸟教程：</p><p><a href="https://www.runoob.com/kotlin/kotlin-tutorial.html">https://www.runoob.com/kotlin/kotlin-tutorial.html</a></p><h3 id="2-自定义控件"><a href="#2-自定义控件" class="headerlink" title="2. 自定义控件"></a>2. 自定义控件</h3><p>安卓内部提供的控件还是非常有限的，所以自定义控件是非常常用的功能，使用自定义控件可以实现更多各种各样的需求。</p><p>Android中所有控件和布局的基类都是View，自定义控件也就是继承View或者View的派生类，然后再重写类中的内部方法。通常来说自定义控件分为三种：<br>1.自定义View：继承View<br>2.基于现有组件：继承View的派生类<br>3.组合的方式：自定义控件中包含了其他的组件</p><h3 id="3-热修复技术"><a href="#3-热修复技术" class="headerlink" title="3. 热修复技术"></a>3. 热修复技术</h3><p>关于Android平台的热修复技术，可以简单理解为通过下发补丁包，让已安装的客户端动态更新，让用户可以不用重新安装APP，就能够修复软件缺陷的一种技术。热修复不仅可以修复代码，同时可以修复资源文件及SO库。现有的热修复框架其实有很多，有开源的也有未开源的，就看大家兴趣啦，靠大家自己去搜索资料去学习啦~</p><p>学习资源(参考)：</p><ul><li><a href="https://www.jianshu.com/p/6ae1e09ebbf5">https://www.jianshu.com/p/6ae1e09ebbf5</a></li><li><a href="https://juejin.cn/post/6844903511243620366#heading-15">https://juejin.cn/post/6844903511243620366#heading-15</a></li></ul><h3 id="4-组件化"><a href="#4-组件化" class="headerlink" title="4. 组件化"></a>4. 组件化</h3><p>Android 组件化就是利用多个 Module来表示应用的多个模块实现代码和资源的隔离，并且每个 Module 都有单独运行和组合的能力。每个功能都是一个 Module，每个功能的代码都在自己所属的 Module 中添加。</p><p>下面链接会有更详细的举例和介绍哦~</p><p>学习资源（参考）</p><ul><li><a href="https://mp.weixin.qq.com/s/ubihF5bDbofZfKTT-Ou2gw">https://mp.weixin.qq.com/s/ubihF5bDbofZfKTT-Ou2gw</a></li><li><a href="https://blog.csdn.net/guiying712/article/details/55213884">https://blog.csdn.net/guiying712/article/details/55213884</a></li></ul><h3 id="5-git和github、gitlab、gitee-码云"><a href="#5-git和github、gitlab、gitee-码云" class="headerlink" title="5. git和github、gitlab、gitee(码云)"></a>5. git和github、gitlab、gitee(码云)</h3><p>git是一个分布式的代码协作工具，有点类似于cmd(命令行工具)。大家可以提前学一下git，也是对大家以后项目协作有所帮助的。</p><p>后面三种都是远程的代码托管平台，可用于版本控制和多人开发。 大家如果感兴趣，可以自行了解三种平台的区别。</p><p>学习资源：</p><ul><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a></li><li><a href="https://learngitbranching.js.org/?locale=zh_CN">https://learngitbranching.js.org/?locale=zh_CN</a></li><li><a href="https://github.com/">https://github.com/</a></li><li><a href="https://gitee.com/">https://gitee.com/</a></li></ul><h3 id="6-博客"><a href="#6-博客" class="headerlink" title="6. 博客"></a>6. 博客</h3><p>几乎每一个学习编程的人都听说过写博客有很多好处，但真的动手去写的其实不算很多。可能有一个原因是，我们会想：我不是什么大牛，写出来的东西没什么意义，也更不会有人看</p><p>实际上，确实是这样的！</p><p>暂时把内容质量和知识分享放一边，记录和回顾的过程还是特别有意义的，一门新技术的学习、一个bug的解决、一个动效的实现、一个项目的总结、一条命令的作用等等，把这些当时遇到的困惑和思考都记下来，之后再遇到相似的，就不需要浪费时间再去百度，谷歌</p><p>写博客的方式有很多，大家多尝试就行了：</p><ul><li>hexo、hugo、wordpress….</li><li>博客园、csdn、掘金、思否….</li><li>自建网站  【百度一下：自建博客网站，会有很多教程的】</li><li>….</li></ul><h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><p>《第一行代码》</p><p>安卓知识体系：<a href="https://blog.csdn.net/qq_29966203/article/details/105455615">https://blog.csdn.net/qq_29966203/article/details/105455615</a></p><p>官方学习网站：<a href="https://developer.android.google.cn/">https://developer.android.google.cn/</a></p><p>安卓官方文档翻译：<a href="https://blog.csdn.net/vanpersie_9987/category_9265821.html?spm=1001.2014.3001.5482">https://blog.csdn.net/vanpersie_9987/category_9265821.html?spm=1001.2014.3001.5482</a></p><p>官方培训课程：<a href="https://developer.android.google.cn/courses">https://developer.android.google.cn/courses</a></p><p>安卓技术社区：<a href="https://www.wanandroid.com/">https://www.wanandroid.com/</a></p><p>​                           <a href="https://www.androidos.net.cn/">https://www.androidos.net.cn/</a></p><p>相关开源项目：<a href="https://zhuanlan.zhihu.com/p/52542420">https://zhuanlan.zhihu.com/p/52542420</a></p><p><a href="https://rengwuxian.com/">https://rengwuxian.com/</a></p><p><a href="https://mp.weixin.qq.com/s/lbxoQcovRgswDgOWvn3jMQ%E3%80%90http://github.com/guolindev/giffun%E3%80%91">https://mp.weixin.qq.com/s/lbxoQcovRgswDgOWvn3jMQ【http://github.com/guolindev/giffun】</a></p><p>安卓基础入门教程PDF打包合集：链接：<a href="https://pan.baidu.com/s/1Ac748bBK7oKHWDwZ39RuWQ">https://pan.baidu.com/s/1Ac748bBK7oKHWDwZ39RuWQ</a><br>提取码：qgo4 </p><p>优达学城(里面有安卓的相关教程，偏基础一点吧)：<a href="https://www.udacity.com/">https://www.udacity.com/</a></p><p>安卓术语集合：<a href="https://s3.cn-north-1.amazonaws.com.cn/static-documents/nd803/Android+for+All+%EF%BC%8D+Vocabulary+Glossary.pdf">https://s3.cn-north-1.amazonaws.com.cn/static-documents/nd803/Android+for+All+%EF%BC%8D+Vocabulary+Glossary.pdf</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android网络连接和网络数据处理</title>
    <link href="/2021/04/17/Android%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <url>/2021/04/17/Android%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP请求方式GET与POST"><a href="#HTTP请求方式GET与POST" class="headerlink" title="HTTP请求方式GET与POST"></a>HTTP请求方式GET与POST</h1><p>在Android开发中我们会接触到数据的交互，比如写入数据、读取数据等，因此我们需要使用通讯间的协议来进行请求，最常见的协议是HTTP协议，而GET和POST则是HTTP协议中最常用的两种请求方式。</p><ul><li>HTTP协议<br>HTTP（HyperText Transfer Protocol超文本传输协议）是一个设计来使客户端和服务器顺利进行通讯的协议。<br>HTTP在客户端和服务器之间以request-response protocol（请求-回复协议）工作。</li><li>GET和POST的区别</li></ul><table><thead><tr><th align="center">GET</th><th align="center">POST</th></tr></thead><tbody><tr><td align="center">一般是从服务器上获取数据</td><td align="center">一般用来上传表单到服务器<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote">&lt;span class=”hint–top hint–rounded” aria-label=” 一般用来上传表单（数据集合）到服务器，服务器处理后再返回数据给客户端。</td></tr><tr><td align="center">Android网络请求Android进行网络请求有三种方法：HttpURLConnection、 HttpClient以及OkHttp。HttpClient由于存在API数量过多、扩展困难等缺点，在Android6.0系统中，该功能已经被正式弃用。而原生的HttpURLConnection是JDK里提供的联网API，但是由于网络操作涉及到异步以及多线程，自己使用原生API编写比较麻烦，所以实际开发更偏向于直接使用第三方网络通信库，而我们今天要介绍的OkHttp就属于众多网络通信库中做的最出色的一个。</td><td align="center"></td></tr><tr><td align="center">OkHttp添加OKHttp库的依赖1compile &#x27;com.squareup.okhttp3:okhttp:3.6.0&#x27;</td><td align="center"></td></tr><tr><td align="center">声明网络权限1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;如果使用了不安全的http链接，应该在在清单文件中声明：1android:usesCleartextTraffic=&quot;true&quot;</td><td align="center"></td></tr><tr><td align="center">简单布局”&gt;[1]</span></a></sup></td><td align="center"></td></tr><tr><td align="center">URL 可见，安全性低</td><td align="center">URL 不可见，安全性高</td></tr><tr><td align="center">提交的数据有长度限制</td><td align="center">提交的数据无长度限制</td></tr><tr><td align="center">数据可缓存</td><td align="center">数据不可缓存</td></tr><tr><td align="center">通过拼接URL进行参数传递</td><td align="center">数据放在请求体中发送</td></tr></tbody></table><p>现在一般使用安全性较高的POST进行请求，在发送密码或其他敏感信息时一定不能使用 GET。POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。GET的数据在 URL 中对所有人都是可见的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;Button<br>        android:id=<span class="hljs-string">&quot;@+id/btn_request&quot;</span><br>        android:layout_width=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:text=<span class="hljs-string">&quot;请求数据&quot;</span>/&gt;<br><br>    &lt;Button<br>        android:id=<span class="hljs-string">&quot;@+id/btn_jump&quot;</span><br>        android:layout_width=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:text=<span class="hljs-string">&quot;跳转解析页&quot;</span>/&gt;<br><br><br>    &lt;TextView<br>        android:id=<span class="hljs-string">&quot;@+id/tv_data&quot;</span><br>        android:layout_width=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h3 id="OkHttp具体用法"><a href="#OkHttp具体用法" class="headerlink" title="OkHttp具体用法"></a>OkHttp具体用法</h3><ol><li>定义并实例化一个OkHttpClient</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient();<br></code></pre></td></tr></table></figure><ol start="2"><li>创建一个Request对象以发起一条HTTP请求，并通过url()方法来设置目标的网络地址。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Request request = <span class="hljs-keyword">new</span> Request.Builder()<br>.url(<span class="hljs-string">&quot;http://106.53.96.124/wanted/public/index.php/index/article/find&quot;</span>)<br>.build();<br></code></pre></td></tr></table></figure><ol start="3"><li>调用OkHttpClient的newCall()方法创建一个Call对象，并调用execute()方法发送请求并获取响应数据。</li><li>定义一个response对象来接收获取到的响应数据，并通过responseData来取得我们返回的具体内容。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Response response = client.newCall(request).execute();<br>String responseData = response.body().string();<br></code></pre></td></tr></table></figure><ol start="5"><li>由于网络请求属于耗时操作，应该在子线程中执行。因此我们在设置点击事件时，在onClick()方法中我们应该新开一个子线程。示例如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">btn_request.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>                <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                        sendRequestWithOkHttp();<span class="hljs-comment">//该方法封装了以上1-4步的内容</span><br>                    &#125;<br>                &#125;).start();<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure></li><li>sendRequestWithOkHttp()方法具体内容如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendRequestWithOkHttp</span><span class="hljs-params">()</span></span>&#123;<br>        OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient();<br>        Request request = <span class="hljs-keyword">new</span> Request.Builder()<br>                .url(<span class="hljs-string">&quot;http://106.53.96.124/wanted/public/index.php/index/article/find&quot;</span>)<br>                .build();<br>        <span class="hljs-comment">//try catch进行异常捕捉</span><br>        <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//同步写法</span><br>            Response response = client.newCall(request).execute();<br>            String responseData = response.body().string();<br>            <span class="hljs-comment">//由于我们进行网络请求是在子线程执行，因此获取到的数据需要从子线程传递到主线程的Ui界面才能显示</span><br>            runOnUiThread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    tv_data.setText(responseData);<br>                &#125;<br>            &#125;);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="同步、异步概念"><a href="#同步、异步概念" class="headerlink" title="同步、异步概念"></a>同步、异步概念</h1><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。当前主线程会阻塞，直到子线程通知主线程为止。<br>（<strong>提交请求 → 等待服务器处理 → 处理完毕返回</strong>）</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>异步方法调用通常会在另外一个线程中继续执行。整个过程，不会阻碍调用者的工作。主线程可以继续干其它的事情，当子线程完成任务的时候通知一下主线程就可以了，类似于接口回调或消息队列的思想。<br>（<strong>请求通过事件触发&gt;服务器处理（无需等待，主线程可以做别的事）&gt;处理完毕</strong>）<br>两者比较更推荐使用异步方法进行网络请求。</p><h2 id="异步方法示例"><a href="#异步方法示例" class="headerlink" title="异步方法示例"></a>异步方法示例</h2><p>定义一个Call对象，并把把request传给call，通过call调用.enqueue()方法执行。需要给enqueue()方法传一个Callback接口的匿名实现类（包含了onFailure()和onRresponse()方法）。<br>以下是异步监听方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendRequestWithOkHttp</span><span class="hljs-params">()</span></span>&#123;<br>        OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient();<br>        Request request = <span class="hljs-keyword">new</span> Request.Builder()<br>                .url(<span class="hljs-string">&quot;http://106.53.96.124/wanted/public/index.php/index/article/find&quot;</span>)<br>                .build();<br>        <span class="hljs-comment">//异步监听写法</span><br>        Call call = client.newCall(request);<br>        call.enqueue(<span class="hljs-keyword">new</span> Callback() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Call call, <span class="hljs-meta">@NotNull</span> IOException e)</span> </span>&#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Call call, <span class="hljs-meta">@NotNull</span> Response response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                String jsonData = response.body().string();<br>                <span class="hljs-comment">//传递到主线程UI界面</span><br>                runOnUiThread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                        tv_data.setText(jsonData);<br>                    &#125;<br>                &#125;);<br>            &#125;<br>        &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a>数据解析</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>一般来说通过网络请求获取到的数据有很多种，xml格式数据、Json格式数据等。我们以上通过网络请求获取到的数据就是Json格式数据。<br>比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;alex&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-string">&quot;18&quot;</span>,<span class="hljs-string">&quot;friends&quot;</span>:[&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;Amy&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-string">&quot;19&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;Jack&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-string">&quot;18&quot;</span>&#125;]&#125;<br></code></pre></td></tr></table></figure><p>以上{}中相当于是一个类的实例，[{},{}]相当于是一个有两个类组成的数组，包括了两个类的实例。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><ol><li>添加Gson库的依赖</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;com.google.code.gson:gson:2.7&#x27;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>新建一个BaseResponse&lt; T &gt;基类来接收我们从服务端获取到的数据，类的内容可以通过Gsonformat插件导入，alt+s唤出插件界面，复制我们的json格式数据，点击OK。</li><li>创建一个parseJSONWithGSON()方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseJSONWithGSON</span><span class="hljs-params">()</span></span>&#123;<br>        Gson gson = <span class="hljs-keyword">new</span> Gson();<br>        <span class="hljs-comment">//由于我们这里需要解析的Json数据中包含了数组，所以需要使用TypeToken将期望解析成数据类型传入到fromJson()方法中</span><br>        BaseResponse&lt;List&lt;BaseResponse.Article&gt;&gt; baseResponse = gson.fromJson(jsonData,<span class="hljs-keyword">new</span> TypeToken&lt;BaseResponse&lt;List&lt;BaseResponse.Article&gt;&gt;&gt;()&#123;&#125;.getType());<br>        List&lt;BaseResponse.Article&gt; articleList = baseResponse.getData();<br>        Log.d(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-string">&quot;code is &quot;</span> + baseResponse.getCode());<br>        Log.d(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;msg is &quot;</span> + baseResponse.getMsg());<br>        <span class="hljs-keyword">for</span> (BaseResponse.Article article:articleList)&#123;<br>            Log.d(<span class="hljs-string">&quot;Data&quot;</span>, <span class="hljs-string">&quot;id is &quot;</span>+article.getId());<br>            Log.d(<span class="hljs-string">&quot;Data&quot;</span>, <span class="hljs-string">&quot;title is &quot;</span>+article.getTitle());<br>            Log.d(<span class="hljs-string">&quot;Data&quot;</span>, <span class="hljs-string">&quot;content is &quot;</span>+article.getContent());<br>            Log.d(<span class="hljs-string">&quot;Data&quot;</span>, <span class="hljs-string">&quot;tags is &quot;</span>+article.getTags());<br>            Log.d(<span class="hljs-string">&quot;Data&quot;</span>, <span class="hljs-string">&quot;create_time is &quot;</span>+article.getCreate_time());<br>            Log.d(<span class="hljs-string">&quot;Data&quot;</span>, <span class="hljs-string">&quot;writer is &quot;</span>+article.getWriter());<br>            Log.d(<span class="hljs-string">&quot;Data&quot;</span>, <span class="hljs-string">&quot;images is &quot;</span>+article.getImages());<br>            Log.d(<span class="hljs-string">&quot;Data&quot;</span>, <span class="hljs-string">&quot;photo is &quot;</span>+article.getPhoto());<br>            Log.d(<span class="hljs-string">&quot;Data&quot;</span>, <span class="hljs-string">&quot;like_number is &quot;</span>+article.getLike_number());<br>            Log.d(<span class="hljs-string">&quot;Data&quot;</span>, <span class="hljs-string">&quot;comment_number is &quot;</span>+article.getComment_number());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li>在点击事件OnClick()方法中，调用parseJSONWithGSON()方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">btn_show.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (jsonData==<span class="hljs-keyword">null</span>)&#123;<br>                    Toast.makeText(MainActivity.<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;数据为空&quot;</span>,Toast.LENGTH_SHORT).show();<br>                &#125;<br>                <span class="hljs-keyword">else</span> parseJSONWithGSON();<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure><h2 id="GsonFormat插件的安装"><a href="#GsonFormat插件的安装" class="headerlink" title="GsonFormat插件的安装"></a>GsonFormat插件的安装</h2></li></ol><p><strong>File→setting→plugin→Marketplace</strong>，搜索gsonformat/Sgsonformat/gsonfromatplus，通过<strong>alt+insert</strong>唤出gsonformat插件，复制json格式数据点击ok。</p><p>接口测试：<a href="https://getman.cn/">https://getman.cn/</a><br>接口文档：<a href="http://www.docway.net/">http://www.docway.net/</a></p><p>参考资料：<br><a href="https://www.jianshu.com/p/ba6998e0dfa7">Android入门之Http请求方式Get与Post</a><br><a href="https://zhuanlan.zhihu.com/p/67452727">同步和异步的区别</a><br><a href="https://www.cnblogs.com/anny0404/p/5691379.html">同步(Synchronous)和异步(Asynchronous)</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>一般用来上传表单（数据集合）到服务器，服务器处理后再返回数据给客户端。<h1 id="Android网络请求"><a href="#Android网络请求" class="headerlink" title="Android网络请求"></a>Android网络请求</h1>Android进行网络请求有三种方法：HttpURLConnection、 HttpClient以及OkHttp。<br>HttpClient由于存在API数量过多、扩展困难等缺点，在Android6.0系统中，该功能已经被正式弃用。而原生的HttpURLConnection是JDK里提供的联网API，但是由于网络操作涉及到异步以及多线程，自己使用原生API编写比较麻烦，所以实际开发更偏向于直接使用第三方网络通信库，而我们今天要介绍的OkHttp就属于众多网络通信库中做的最出色的一个。<h2 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h2><h3 id="添加OKHttp库的依赖"><a href="#添加OKHttp库的依赖" class="headerlink" title="添加OKHttp库的依赖"></a>添加OKHttp库的依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">compile <span class="hljs-string">&#x27;com.squareup.okhttp3:okhttp:3.6.0&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="声明网络权限"><a href="#声明网络权限" class="headerlink" title="声明网络权限"></a>声明网络权限</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;uses-permission android:name=<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><br>如果使用了不安全的http链接，应该在在清单文件中声明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">android:usesCleartextTraffic=<span class="hljs-string">&quot;true&quot;</span><br></code></pre></td></tr></table></figure><h3 id="简单布局"><a href="#简单布局" class="headerlink" title="简单布局"></a>简单布局</h3><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Intent—Android系统的通信桥梁</title>
    <link href="/2020/11/14/Intent%E2%80%94Android%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%80%9A%E4%BF%A1%E6%A1%A5%E6%A2%81/"/>
    <url>/2020/11/14/Intent%E2%80%94Android%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%80%9A%E4%BF%A1%E6%A1%A5%E6%A2%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h1><h2 id="定义及作用"><a href="#定义及作用" class="headerlink" title="定义及作用"></a>定义及作用</h2><p>Intent：意图。它是Android程序中各组件之间进行交互的一种重要方式，它不仅可以<strong>启动新组件</strong>、<strong>调用别的应用程序</strong>、还可以在<strong>不同组件及应用程序之间传递数据</strong>。<br>一个Intent对象就是对一次将要执行操作的抽象描述。Intent代表了Android应用的启动意图，Android应用将会根据Intent来启动指定组件，至于到底启动哪个组件，则取决于Intent的各<strong>属性</strong>，我们稍后将会进行详细介绍。Intent负责对应用中一次操作的动作、动作涉及数据、附加数据进行描述，Android则根据此Intent的描述，负责找到对应的组件，将 Intent传递给调用的组件，并完成组件的调用。<br>我们以一段比喻来理解，比如我们平常的点外卖，把外卖看成一个个的Intent，把外卖员看成Android系统，他会根据每个外卖上面信息（地址、电话）的不同描述，向每个个人传递相关信息，把外卖送到每个人的手上，完成外卖配送这样子。Intent也是一样，携带着一定的信息，通过Android应用去判断信息进而启动新组件或应用程序、传送数据到新的组件或应用程序中。<br>Intent一般可被用于<strong>启动活动</strong>、<strong>启动服务</strong>、<strong>发送广播</strong>以及<strong>携带数据到其他组件中</strong>等场景。本节课我们将以<strong>启动活动</strong>、<strong>传递数据</strong>为主向大家讲述<strong>Intent</strong>各种神奇的作用。</p><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><h3 id="显式intent"><a href="#显式intent" class="headerlink" title="显式intent"></a>显式intent</h3><p>通过提供目标应用的软件包名称或完全限定的组件类名来指定可处理 Intent 的应用。它一般用在源组件已知目标组件名称的前提下，这种方式一般在应用程序内部实现。比如在某应用程序内，一个 Activity 启动一个 Service或一个Activity启动另一个Activity等。<br>我们先来试一下显式Intent如何使用。<br>新建IntentTest项目–&gt;新建second_activity.xml以及SecondActivity.java<br>在activity_main.xml文件下添加一个Button控件如下：<br><img src="https://img-blog.csdnimg.cn/20201114151327657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcxNTI4Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="按钮"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;Button<br>        android:id=<span class="hljs-string">&quot;@+id/button_1&quot;</span><br>        android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:text=<span class="hljs-string">&quot;显式启动一个新的Activity&quot;</span><br>        android:layout_marginTop=<span class="hljs-string">&quot;20dp&quot;</span><br>        android:layout_marginLeft=<span class="hljs-string">&quot;20dp&quot;</span><br>        android:layout_marginRight=<span class="hljs-string">&quot;20dp&quot;</span><br>        android:onClick=<span class="hljs-string">&quot;buttonOne&quot;</span><br>        /&gt;<br></code></pre></td></tr></table></figure><p>在MainActivity中添加点击按钮的的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buttonOne</span><span class="hljs-params">(View view)</span></span>&#123;<br>       Intent intent = <span class="hljs-keyword">new</span> Intent(MainActivity.<span class="hljs-keyword">this</span>,SecondActivity.class);<br>       startActivity(intent);<br>   &#125;<br></code></pre></td></tr></table></figure><p>并在Button控件中添加OnClick属性设置回调方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">android:onClick=<span class="hljs-string">&quot;buttonOne&quot;</span><br></code></pre></td></tr></table></figure><p>因为神奇的Intent，我们通过点击按钮就可以成功的启动一个新的活动啦。<br>这个时候如果你想回到上一个活动怎么办呢，按下Back键就可以回到上一个活动了。<br>由于使用这种方法来启动活动，Intent的“意图”非常明显，因此我们称之为<strong>显式Intent</strong>。</p><h3 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="隐式Intent"></a>隐式Intent</h3><p>隐式Intent就比较含蓄了，它不会指定特定的组件，也就是不会明确指出要我们启动哪一个活动，而是指定一系列action和category等信息，让系统去分析这个Intent并帮我们找出合适的活动去启动。<br>使用隐式 Intent 时，Android 系统通过将 Intent 的内容与在设备上所有应用（包括自身应用）的清单文件中声明的 Intent 过滤器进行比较，从而找到要启动的相应组件。如果 Intent 与 Intent 过滤器匹配，则系统将启动该组件，并向其传递 Intent 对象。如果多个 Intent 过滤器兼容，则系统会显示一个对话框，用户自行选取要使用的应用。<br>现在我们来试试通过隐式Intent启动一个活动。<br>再在activity_main.xml文件下添加另一个Button控件如下：<br><img src="https://img-blog.csdnimg.cn/20201114153945466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcxNTI4Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="新按钮"><br>再新建一个新建third_activity.xml以及ThirdActivity.java文件，并在Android Manifest.xml中注册ThirdActivity，并声明本活动的Intent-Filter</p><pre><code> intent-filter（Intent过滤器）：一个隐式 Intent 请求要能够传递到目标组件，必须要通过 Action、Data 以及 Category 三个属性的检查。 就是说Action、Data 以及 Category是通行证， 如果他们的任何一个值不符合，该隐式Intent将不会被传递给目标组件。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;activity android:name=<span class="hljs-string">&quot;.ThirdActivity&quot;</span>&gt;<br>            &lt;intent-filter&gt;<br>                &lt;action android:name=<span class="hljs-string">&quot;android.intent.action.VIEW&quot;</span>/&gt;<br>                &lt;category android:name=<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;<br>            &lt;/intent-filter&gt;<br>        &lt;/activity&gt;<br></code></pre></td></tr></table></figure><p>然后到MainActivity添加点击按钮的的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buttonTwo</span><span class="hljs-params">(View view)</span></span>&#123;<br>      Intent intent = <span class="hljs-keyword">new</span> Intent(Intent.ACTION_VIEW);<br>      intent.addCategory(<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span>);<br>      startActivity(intent);<br>  &#125;<br></code></pre></td></tr></table></figure><p>同理，在Button控件中添加OnClick属性设置回调方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">android:onClick=<span class="hljs-string">&quot;buttonTwo&quot;</span><br></code></pre></td></tr></table></figure><p>现在点击按钮，你同样成功启动一个新的活动，但不同的是你这次使用了<strong>隐式Intent</strong>的方式来启动。这就说明我们在Android Manifest.xml下配置的action以及category内容生效啦！</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>Intent中包含的属性主要有：Component(目标组件),Action(动作),Category(类别), Data(数据),Type(数据类型),Extra（附加信息）,Flag（标记）这7个属性。</p><h3 id="（1）Component（组件信息）"><a href="#（1）Component（组件信息）" class="headerlink" title="（1）Component（组件信息）"></a>（1）Component（组件信息）</h3><p>Intent 的 Compotent 属性指定 Intent 的目标组件的类名称。使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Intent intent = <span class="hljs-keyword">new</span> Intent(context, OtherActivity.class);<br></code></pre></td></tr></table></figure><p>Context是上下文也就是当前的activity，后面的xxx.class则是我们通过intent要启动的新活动，参考我们上面使用显式intent启动活动的例子。</p><h3 id="（2）Action（动作）"><a href="#（2）Action（动作）" class="headerlink" title="（2）Action（动作）"></a>（2）Action（动作）</h3><p>代表Intent要完成的一个抽象“动作”，比如发信息的权限，而具体要由哪个组件完成，Intent并不负责！它仅仅知道有这个Action，谁来完成就要通过Intent-filter筛选。<br>Intent中的Action必须能够和Android Manifest.xml中对应组件的Intent-filter的Action匹配(这里的匹配是完全相等)。 Android Manifest.xml中对应组件的Intent-filter中可以有多个action，但是只要Intent中的action能够和Android Manifest.xml中对应组件的Intent-filter中的任何一个action相同即可匹配成功。参考上面隐式Intent调用的例子。<br><strong>常用的Action</strong><br>|  动作名称| 动作功能|<br>|–|–|<br>| ACTION_M AIN|作为一个主要的进入口，而并不期望去接受数据|<br>|ACTION_VIEW    |向用户去显示数据|<br>|ACTION_ATTACH_DATA|    别用于指定一些数据应该附属于一些其他的地方，例如，图片数据应该附属于联系人|<br>|ACTION_EDIT|访问已给的数据，提供明确的可编辑|<br>|ACTION_PICK    |从数据中选择一个子项目，并返回你所选中的项目|<br>|ACTION_CHOOSER    |显示一个 activity 选择器，允许用户在进程之前选择他们想要的|<br>|ACTION_GET_CONTENT    |允许用户选择特殊种类的数据，并返回（特殊种类的数据：照一张相片或录一段音）|<br>|ACTION_DIAL|拨打一个指定的号码，显示一个带有号码的用户界面，允许用户去启动呼叫<br>|ACTION_CALL    |根据指定的数据执行一次呼叫（ACTION_CALL 在应用中启动一次呼叫有缺陷，多数应用 ACTION_DIAL，ACTION_CALL 不能用在紧急呼叫上，紧急呼叫可以用 ACTION_DIAL 来实现）|<br>|ACTION_SEND    |传递数据，被传送的数据没有指定，接收的 action 请求用户发数据|<br>|ACTION_SENDTO    |发送一条信息到指定的某人|<br>|ACTION_ANSWER    |处理一个打进电话呼叫|<br>|ACTION_INSERT |    插入一条空项目到已给的容器|<br>|ACTION_DELETE|    从容器中删除已给的数据|<br>|ACTION_RUN|    运行数据|<br>|ACTION_SYNC    |同步执行一个数据|<br>|ACTION_PICK_ACTIVITY    |为以为的 Intent 选择一个 Activity，返回别选中的类|<br>|ACTION_SEARCH    |执行一次搜索|<br>|ACTION_WEB_SEARCH    |执行一次 web 搜索|<br>|ACTION_FACTORY_TEST    |工场测试的主要进入点|</p><h3 id="（3）Category（类别）"><a href="#（3）Category（类别）" class="headerlink" title="（3）Category（类别）"></a>（3）Category（类别）</h3><p>Category用于为Action提供额外的附加类别信息，两者通常结合使用。<br>如果Intent设置了category，那么Intent中存在的所有的category都必须和Android Manifest.xml中对应组件的Intent-filter中的category相同，才能和这个Activity匹配。<br><strong>常用的Category</strong><br>|名称| 组件类别 |<br>|–|–|<br>| CATEGORY_DEFAULT|Android系统中默认的执行方式，按照普通Activity的执行方式执行|　<br>|CATEGORY_HOME|设置该组件为Home Activity|<br>|CATEGORY_PREFERENCE|设置该组件为Preference|　<br>|CATEGORY_LAUNCHER|设置为当前应用程序优先级最高的Activity，通常与ACTION_MAIN配合使用|　<br>|CATEGORY_BROWSABLE|设置该组件可以使用浏览器启动|　<br>|CATEGORY_GADGET|设置该组件可以内嵌到另外的Activity中|</p><h3 id="（4）Data（数据）"><a href="#（4）Data（数据）" class="headerlink" title="（4）Data（数据）"></a>（4）Data（数据）</h3><p>通常用于向Action属性提供操作的数据，接受一个URI对象。匹配规则与Action类似。<br>下面我们通过实践来使用data隐式启动百度网页。<br>再在activity_main.xml文件下添加另一个Button控件，然后直接在MainActivity添加点击按钮的的方法，xml布局中Button控件中添加OnClick属性设置回调方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buttonThree</span><span class="hljs-params">(View view)</span></span>&#123;<br>      Intent intent = <span class="hljs-keyword">new</span> Intent(Intent.ACTION_VIEW);<br>      intent.setData(Uri.parse(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>));<br>      startActivity(intent);<br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">android:onClick=<span class="hljs-string">&quot;buttonThree&quot;</span><br></code></pre></td></tr></table></figure><p>现在点击按钮就会直接跳转到浏览器的百度页面，当然这里如果你的手机里有多个可打开网址的app，还会弹出一个对话框让你自己选择。<br>intent-filter中的data标签主要可配置以下内容：<br>|名称| 作用 |<br>|–|–|<br>| android:scheme | 用于指定数据的协议部分，如上例中的http部分 |<br>|android:host|用于指定数据的主机名部分，如上例中的<a href="http://www.baidu.com部分|/">www.baidu.com部分|</a><br>|android:port|用于指定数据的端口部分，一般紧随在主机名之后|<br>|android:path|用于指定主机名与端口之后的部分，如一段网址中跟在域名之后的内容|<br>|android:mimeType|用于指定可以处理的数据类型，允许使用通配符的方式进行指定|<br>只有&lt;data<data>&gt;标签中指定的内容和Intent中携带的Data完全一致时，当前活动才能够响应该Intent。</p><h3 id="（5）Type（数据类型）"><a href="#（5）Type（数据类型）" class="headerlink" title="（5）Type（数据类型）"></a>（5）Type（数据类型）</h3><p>Intent 的 Type 属性显示指定 Intent 的数据类型（MIME）。通常 Intent 的数据类型可以从 Data 自身判断出来，但是一旦指定了 Type 类型，就会强制使用 Type 指定的类型而不再进行推导。</p><h3 id="（6）Extra（附加信息）"><a href="#（6）Extra（附加信息）" class="headerlink" title="（6）Extra（附加信息）"></a>（6）Extra（附加信息）</h3><p>Intent 的 Extra 属性用于添加一些组件的附加信息。比如，要通过一个 Activity 执行“发送电子邮件”这个动作请求，可以将电子邮件的 subject、body 等保存在 Extras 里，传给电子邮件发送组件。</p><h3 id="（7）flag（标记）"><a href="#（7）flag（标记）" class="headerlink" title="（7）flag（标记）"></a>（7）flag（标记）</h3><p>flag在 Intent 类中定义，充当 Intent 的元数据。flag可以指示 Android 系统如何启动 Activity（例如，Activity 应属于哪个任务），以及启动之后如何处理（例如，Activity 是否属于最近的 Activity 列表）。</p><h2 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h2><h3 id="（1）向下一个活动传值"><a href="#（1）向下一个活动传值" class="headerlink" title="（1）向下一个活动传值"></a>（1）向下一个活动传值</h3><p>我们上面已经学过如何显式启动一个新的activity了，现在我们来学怎么给下一个活动传值。新建一个活动FourthActivity以及fourth_layout布局，在MainActivity中我们再写一个新的方法，实例化Intent对象，通过putExtra(“name”,data)给我们实例化的intent对象设置一个值，让他可以通过startActivity将值传输到下一个活动。（这里的name是一个标识符，取值需要通过这个标识符来取，data是我们要传输的数据）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buttonFour</span><span class="hljs-params">(View view)</span></span>&#123;<br>       Intent intent = <span class="hljs-keyword">new</span> Intent(MainActivity.<span class="hljs-keyword">this</span>, FourthActivity.class);<br>       intent.putExtra(<span class="hljs-string">&quot;extra_data&quot;</span>,<span class="hljs-string">&quot;Make it real!&quot;</span>);<br>       startActivity(intent);<br>   &#125;<br></code></pre></td></tr></table></figure><p>在fourth_layout布局中添加一个TextView用来显示我们从MainActivity获得的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;TextView<br>        android:id=<span class="hljs-string">&quot;@+id/text_1&quot;</span><br>        android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:layout_marginTop=<span class="hljs-string">&quot;20dp&quot;</span><br>        android:layout_marginLeft=<span class="hljs-string">&quot;20dp&quot;</span><br>        android:layout_marginRight=<span class="hljs-string">&quot;20dp&quot;</span><br>        android:text=<span class="hljs-string">&quot;这是一个用来显示由上一个Activity传过来的值的TextView&quot;</span><br>        android:gravity=<span class="hljs-string">&quot;center_horizontal&quot;</span> /&gt;<br><br></code></pre></td></tr></table></figure><p>运行发现并没有值出现，这是因为我们传值了，但是没有在FourthActivity中把值取出来。这个时候我们需要在FourthActivity中去获取这个intent，就需要用到getIntent（）方法了，再通过intent.getStringExtra(“标识符”);来获取数据，然后用display（）方法让我们的数据显示出来吧。<br>在FourthActivity中添加代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Intent intent = getIntent();<br>        String data = intent.getStringExtra(<span class="hljs-string">&quot;extra_data&quot;</span>);<br>        display(data);<span class="hljs-comment">//这部分添加到onCreate方法中</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(String data)</span></span>&#123;<br>        TextView textView = findViewById(R.id.text_1);<br>        textView.setText(data);<br>    &#125;<br></code></pre></td></tr></table></figure><p>现在点击按钮，我们可以发现我们成功把值传到了下一个活动啦。这就是向下一个活动传值的方法。下面我们来介绍怎么向上一个活动返回数据。</p><h3 id="（2）向上一个活动传值"><a href="#（2）向上一个活动传值" class="headerlink" title="（2）向上一个活动传值"></a>（2）向上一个活动传值</h3><p>既然可以传值给下一个活动，当然要实现返回数据给上一个活动才比较人性化呀~所以我们现在来学学如何通过intent给上一个活动返回数据。<br>首先把我们MainActivity中的的startActivity()方法改为startActivityForResult()方法。这是不影响我们向下一个活动传值的，但是通过这个方法，我们就可以在下一个活动被销毁的时候给上一个活动返回数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">startActivityForResult(intent,<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>在activity_main中添加一个TextView控件以显示我们从FourthActivity获取到的值，并在MainActivity中添加文字显示的方法display()；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;TextView<br>        android:id=<span class="hljs-string">&quot;@+id/text_1&quot;</span><br>        android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:layout_marginTop=<span class="hljs-string">&quot;20dp&quot;</span><br>        android:layout_marginLeft=<span class="hljs-string">&quot;20dp&quot;</span><br>        android:layout_marginRight=<span class="hljs-string">&quot;20dp&quot;</span><br>        android:text=<span class="hljs-string">&quot;这是一个用来显示由下一个Activity传回来的值的TextView&quot;</span><br>        android:gravity=<span class="hljs-string">&quot;center_horizontal&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(String data)</span></span>&#123;<br>       TextView textView = findViewById(R.id.text_1);<br>       textView.setText(data);<br>   &#125;<br></code></pre></td></tr></table></figure><p>给fourth_layout布局添加一个按钮</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;Button<br>        android:id=<span class="hljs-string">&quot;@+id/button_1&quot;</span><br>        android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:layout_gravity=<span class="hljs-string">&quot;center&quot;</span><br>        android:layout_marginTop=<span class="hljs-string">&quot;20dp&quot;</span><br>        android:text=<span class="hljs-string">&quot;向上一个Activity传值&quot;</span><br>        android:onClick=<span class="hljs-string">&quot;buttonBack&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>然后在FourthActivity中我们来写一个方法，实现点击事件并在方法中添加返回数据的逻辑。SetResult方法是专门向上一个活动返回数据的，第一个参数用于向上一个活动返回处理结果，一般只是用RESULT_OK或RESULT_CANCELED两个值；第二个参数则是我们要返回的带有数据的intent对象。最后调用finish（）方法销毁当前活动返回到上一个活动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buttonBack</span><span class="hljs-params">(View view)</span></span>&#123;<br>     Intent intent = <span class="hljs-keyword">new</span> Intent();<br>     intent.putExtra(<span class="hljs-string">&quot;data_return&quot;</span>,<span class="hljs-string">&quot;Let&#x27;s make it real!&quot;</span>);<br>     setResult(RESULT_OK,intent);<br>     finish();<br> &#125;<br></code></pre></td></tr></table></figure><p>由于我们是使用startActivityForResult（）方法来启动下一个活动的，因此在下一个活动被销毁之后会回调上一个活动的onActivityResult（）方法，因此我们需要在MainActivity中重写该方法来获取数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">int</span> resultCode,Intent data)</span> </span>&#123;<br>       <span class="hljs-keyword">super</span>.onActivityResult(requestCode, resultCode, data);<br>       <span class="hljs-keyword">switch</span> (requestCode) &#123;<br>           <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>               <span class="hljs-keyword">if</span> (resultCode == RESULT_OK) &#123;<br>                   String returnedData = data.getStringExtra(<span class="hljs-string">&quot;data_return&quot;</span>);<br>                   Log.d(<span class="hljs-string">&quot;MainActivity&quot;</span>, returnedData);<br>                   display(returnedData);<br>               &#125;<br>               <span class="hljs-keyword">break</span>;<br>           <span class="hljs-keyword">default</span>:<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>onActivityResult（）方法中有三个参数，相信大家都觉得很眼熟，就是我们上面设置过的requestCode、resultCode以及带着返回数据的Intent。由于在一个活动中有可能调用startActivityForResult（）方法去启动很多不同的活动，所以requestCode的值有可能不同，所以我们需要判断requestCode的数据来源，确定数据是否是从FourActivity传过来的，再通过resultCode判断处理结果是否成功，最后再从intent中取值并把值显示出来。<br>现在点击按钮我们就能把FourthActivity中Intent设置的值传到MainActivity中并显示出来啦。</p><p><strong>四大组件</strong>：<a href="https://blog.csdn.net/xchaha/article/details/80398620">https://blog.csdn.net/xchaha/article/details/80398620</a></p><pre><code> 鉴于可能还有人没去了解Android四大组件，这里推一个博客大家可以看看，我们本节课Intent就与Android四大组件之三（活动、广播、服务）密切相关)</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://baike.baidu.com/item/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/20365693">郭神的《第一行代码》</a><br><a href="https://developer.android.google.cn/guide/components/intents-filters?hl=zh-cn#Resolution">Intent和Intent过滤器</a><br><a href="https://blog.csdn.net/jijiangpeng/article/details/95929142?utm_medium=distribute.pc_relevant_t0.none-task-blog-OPENSEARCH-1.pc_relevant_is_cache&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-OPENSEARCH-1.pc_relevant_is_cache">Android Intent：不同应用程序之间通信的桥梁</a><br><a href="https://blog.csdn.net/taiyuanwuyin/article/details/77976797">Android中的Intent和Intent-filter总结</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
